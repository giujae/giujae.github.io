---
title: Week11_day8
date: 2024-09-26 11:00:35 +09:00
categories: [크래프톤 정글, TIL, pintOS]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    pintOS,
    .
    .
    .
  ]
---

오늘은 이번주에 pintOS 3번째 과제 vm을 구현한 부분까지 전체 흐름과 과정을 정리하려고 한다.

## 개요

지난 프로젝트까지는 pml4라는 페이지 테이블을 통해 가상메모리와 물리 메모리 간의 매핑을 관리하였는데, 이제 page fault과 자원관리를 다루기 위해서 각각의 페이지에 대한 추가 정보를 가지는 supplementary page table의 추가가 필요하다.

#### Supplementary page table

pintOS의 spt의 역할은 크게 두 가지가 있다.

- page fault 발생 시 커널이 spt 에서 오류가 발생한 가상 페이지를 조회하여 어떤 데이터가 있어야 하는지 확인할 수 있어야 한다.
- 프로세스가 종료될 때, 커널이 spt를 참조하여 어떤 리소스를 free할 지 정할 수 있어야 한다.

  - 추가적인 역할
    - 서로 다른 두 페이지 테이블 엔트리(서로다른 두 프로세스)가 같은 물리주소를 가리킬 수도 있는데, 이 때 누가 어떤 물리 메모리를 참조하는지 기록한다.
    - 기존 page table은 물리메모리를 향한 일방적인 pointing이기 때문에 값의 변동이 있으면 panic이 발생했다. 때문에 원래 어떤 데이터가 물리메모리에 있어야 했는지를 기록한다.

### 구현 방향성

spt를 구현함에 있어서 선택지가 4가지가 있었다.

- array : 가장 구현이 간단하지만, 공간복잡도가 크다는 단점이 있다. 시간 복잡도는 O(1)이다.
- linked list : 역시 간단하지만, 탐색을 함에 일일히 탐색을 해야하기 때문에 O(n)으로 오래 걸린다.
- hash table : key->value의 구조로 value = get(key)가 O(1)으로 빠르고, array와 다르게 연속적인 공간을 가질 필요가 없기 때문에 공간복잡도도 유리하다.
- Bitmap : 데이터를 비트에 매핑시키는 자료구조로 비트를 통해 저장하기 때문에 공간복잡도에서 매우 유리하며, 자료가 많지 않을 때는 효율적이나 많아질수록 복잡해진다.

때문에 각각의 특성을 고려하여 가장 적합한 자료구조로 hash table을 선택하게 되었다.

#### hash table

이렇게 선택 받은 자료구조임에도 명확한 단점이 존재한다.  
서로 다른 key 값에 대해서 같은 index 값이 도출되어 충돌이 발생할 수 있다는 점이다.

이는 충돌이 발생했을 경우 연결리스트로 연결하여 해결(chaining)할 수 있으나, 최악의 경우에는 한 인덱스에 모두 연결리스트로 저장되어 시간 복잡도가 O(n)이 될 수 있다는 단점이 있다.

> 이렇게 모든 방법에는 정답이 없고 장단점이 항상 존재하니 꼭 상황에 맞는지 고려해 보고 사용하는 습관을 기르자!

hash table에는 총 3가지 고려할 요소가 존재하게 된다.

- hash function을 통해 나온 index.
- 해당 index에 값을 저장하게 되는 bucket(array).
- 충돌이 발생할 경우 생기게 되는 연결리스트(hash_elem을 가지게 될 것).

이제 시작해보자!

## 구현

### Supplemental page table

#### struct supplemental_page_table

![spt](../../assets/img/post_img/20240926/spt.png){: style="display: block; margin-left: auto; margin-right: auto; width: 80%;" }

위해서 hash_table을 이용해 구현하기로 했기 때문에, hash 구조체를 추가해 준다.

```c
struct supplemental_page_table {
    struct hash spt_hash;
}
```

#### struct page

![page](../../assets/img/post_img/20240926/page.png){: style="display: block; margin-left: auto; margin-right: auto; width: 80%;" }

spt 에 해당 page를 연결해 줄 수 있도록 hash_elem을 추가해 준다!

```c
struct page {
    ...
    struct hash_elem hash_elem;
}
```

spt는 key : page->va, value : struct page 를 가지는 형태로 사용될 것이다.

#### struct hash

그럼 이제 우리가 사용할 hash 구조체를 살펴보자.

![hash](../../assets/img/post_img/20240926/hash.png){: style="display: block; margin-left: auto; margin-right: auto; width: 80%;" }

위에서 언급했듯이, hash table은 array와 array에 달리는 linked list의 조합으로 이루어져 있는데, page의 가상 주소(va)를 hash function을 통해서 hash table의 index로 변경하여 해당 index와 매핑된 bucket의 hash_elem을 통해서 해당 page를 찾을 수 있게 되는 구조이다.  
물론 연결리스트는 hash_elem의 연속이다.

![info](../../assets/img/post_img/20240926/info.png){: style="display: block; margin-left: auto; margin-right: auto; width: 80%;" }

해당 주석은 pintOS에 구현되어있는 hash table에 대한 설명인데, 살펴보면 chaining에 사용되는 연결리스트는 동적 할당을 사용하는 대신, hash table에 들어갈 수도 있는 모든 page 구조체는 hash_elem을 멤버로가지고, hash_entry 매크로를 통해 hash_elem으로 부터 page 구조체를 찾을 수 있음을 알려주고 있다(project1, 2에서도 자주 사용하던 방법).

#### hash init

![hash_init](../../assets/img/post_img/20240926/hash_init.png){: style="display: block; margin-left: auto; margin-right: auto; width: 80%;" }

위에서 살펴본 hash 자료구조를 초기화 해주는 함수로, 인자로 주어지는 hash_hash_func, hash_less_func가 앞으로 구현해야할 함수가 되겠다.

근데 살펴보면 init 내부에서 malloc(동적할당)을 사용하고 있다.

![what](../../assets/img/post_img/20240926/what.png){: style="display: block; margin-left: auto; margin-right: auto; width: 60%;" }

안쓴다며????

해서 다시 읽어보니 malloc을 하고 있는 것은 bucket이다. bucket은 array 였다.  
hash function을 통해 hash_index가 된 va 값을 기준으로 가지는 array인 bucket에 hash_elem의 연속인 연결리스트가 붙는다.

즉 chaining에 사용되는 연결리스트에는 page 생성될 때 만들어지는 hash_elem이 사용된다. 고로 동적할당을 하지 않는다.

![ok](../../assets/img/post_img/20240926/ok.png){: style="display: block; margin-left: auto; margin-right: auto; width: 100%;" }
