---
title: Week9_day2
date: 2024-09-05 10:14:35 +09:00
categories: [크래프톤 정글, TIL, pintOS]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    pintOS,
    .
    .
    .
  ]
---

오늘은 USER PROGRAMS의 Argument Passing에 대해 공부한다.

## Argument Passing

process_exec()에 있는 유저 프로그램을 위한 인자를 설정한다.

### x86-64 Calling Convention

이 섹션에서는 Unix의 64비트 x86-64 구현에서 일반 함수 호출에 사용되는 규칙의 중요점을 요약한다.

- 인수 전달 방식  
  User-level 어플리케이션들은 정수 레지스터를 통해 %rdi, %rsi, %rdx, %rcx, %r8, %r9 시퀸스를 전달한다(만약 6개 이상의 인자를 받으면 스택에 쌓여서 전달 됨).
- CALL 명령어  
  함수를 호출할 때 사용되며, 호출자의 다음 명령어 주소(리턴주소)를 스택에 저장한 후, 호출하려는 함수의 첫 번째 명령어로 점프한다. 즉 함수 호출 시 스택에 리턴 주소를 저장한다.
- 피호출 함수 실행  
  레지스터에 전달 된 인자를 사용하여 작업을 수행한다.
- 리턴 값 저장  
  피호출자가 리턴 값이 있으면 rax 레지스터에 저장한다.
- RET 명령어  
  함수가 종료되면 RET 명령어가 실행 되어 스택에 저장된 리턴 주소를 꺼내서 해당 주소로 점프하는 방식으로 호출자에게 돌아가고, 호출자는 계속에서 자신의 작업을 이어서 수행한다.

### 프로그램 시작의 디테일

pintOS에서 유저 프로그램이 실행 될 때, 진입점 함수는 \_start()이다.  
이 함수는 main()함수를 호출하고, main()이 종료 되면 exit()를 호출하여 프로그램을 종료한다.

```c
void _start (int argc, char *argv[]) {
    exit(main(argc, argv));
}
```

argc는 명령줄 인자의 개수, argv는 명령줄 인자 배열의 시작 주소이다.

#### 명령어 인자의 처리

사용자 프로그램이 시작되기 전에, 커널은 명령어 인자를 레지스터에 저장해야 한다. 명령어 인자는 일반적인 호출 규약과 같은 방식으로 전달된다.

예를 들어 /bin/ls -l foo bar라는 명령을 입력했다고 가정하겠다.

이 명령은 프로그램 이름과 3개의 인자로 나뉜다.

- /bin/ls
- -l
- foo
- bar
  이를 명령어 단위로 쪼개어 스택에 올려야 한다(포인터를 통해 접근할 것이기 때문에 순서는 관계 없다).

#### 명령어 주소를 스택에 저장

각 명령어 문자열의 주소를 스택에 차례대로 저장한다. 이 때 NULL 포인터를 추가하여, argv[argc] == NULL 이라는 조건을 충족할 수 있도록 한다.  
스택에 저장하는 순서는 명령어의 오른쪽에서 왼쪽으로 저장되며, 가장 먼저 NULL 포인터를 푸시하고, 이를 통해 argv[0]이 가장 낮은 가상주소가 될 수 있도록 한다. 이후 각 명령어의 주소를 스택에 넣어 argv 배열을 완성한다(스택은 성장할수록 주소값이 낮아지기 때문에 명령어의 오른쪽에서부터 스택에 푸시하게 되면, 가장 나중에 저장한 값이 가장 낮은 주소에 위치하게 된다. 때문에 argv[0]이 가장 낮은 주소에, NULL 포인터가 가장 높은 주소에 있을 수 있다).

#### 스택 정렬(8byte)

스택 정렬은 성능에 중요한 영향을 준다.  
x86-64 아키텍쳐에서는 8바이트 단위로 정렬한 메모리 접근이 더 빠르기 때문에, 스택 포인터는 항상 8의 배수로 정렬되어야 한다. 이를 위해 스택 포인터를 8바이트의 경계로 맞춘다.

> 메모리의 정렬  
> 운영체제가 64비트이기 때문에 주소 크기가 64비트로 관리되고, 한 번에 처리할 수 있는 데이터 양 또한 레지스터가 64비트로 8바이트이다 만약 데이터를 8의 배수로 정렬하지 않는다면 4바이트의 데이터만 찾으려면 CPU는 8바이트 단위로 데이터를 읽기 때문에 8바이트의 경계를 넘어 4바이트의 데이터가 있을 수 있다. 그럼 앞 뒤 메모리를 모두 접근한 뒤 필요한 데이터를 추출하는 과정이 필요하게 되고, 이는 추가적인 연산이나 메모리 접근을 야기한다.  
> 반면 정렬된 메모리는 한 번의 접근으로 데이터를 처리할 수 있어 메모리 대역폭을 더 효율적으로 사용하며, 추가적인 연산이 필요 없게 된다.

#### 레지스터 설정

명령어와 명령어 주소가 스택에 올려진 후, 레지스터 설정이 필요하다.

- %rdi : 명령어 인수의 개수 (argc)
- %rsi : 명령어 배열의 시작 주소 (argv[0]의 주소 = argv의 주소)

#### 가짜 반환 주소

이 시작함수는 절대 리턴하지 않겠지만, 해당 스택 프레임 또한 다른 것과 동일한 구조를 가지도록 가짜 반환 주소를 푸시한다.
