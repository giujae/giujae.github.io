---
title: Week9_day1
date: 2024-09-04 14:21:35 +09:00
categories: [크래프톤 정글, TIL, pintOS]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    pintOS,
    .
    .
    .
  ]
---

오늘은 pintOS 2주차 USER PROGRAMS의 이론을 정리하려한다.

## USER PROGRAMS

### 프로젝트 소개

Threads 프로젝트까지는 운영체제 커널 영역을 다루고 있었기 때문에 시스템에 전체에 대한 권한을 가지고 작업을 했었다.  
그러나 이번 User programs 프로젝트에서는 유저 프로그램을 실행할 수 있는 시스템 영역을 다룰 것이다.  
그러기 위해 프로그램이 OS와 시스템 콜을 통해 상호작용하도록 할 것이다.

이번 프로젝트는 지난 프로젝트의 위에 만들어야 하고, 지난 프로젝트의 테스트도 모두 통과해야 한다.  
또한 추가 챌린지가 존재하지만 스켈레톤 코드가 존재하지 않고, TODO가 없는 코드라고 해도 수정해야 할 수도 있다는 점에 유의해야 한다.

### 배경 지식

지금까지의 코드는 운영체제의 커널의 일부였다. 그렇기 때문에 모든 테스트 코드는 커널의 일부로서 시스템의 모든 부분에 대한 권한이 있었다.  
이제 운영체제 위에서 유저 프로그램을 사용하기 시작하면 더 이상 그렇지 못하기 때문에 이를 관리하는 것이 이번 과제이다.

동시에 여러 프로세스가 실행될 수 있게 할 것이고, 각 프로세스는 하나의 쓰레드를 가진다(멀티 쓰레드 프로세스는 지원하지 않는다).  
유저 프로그램은 각각 자신이 독점해서 사용하고 있다는 착각을 하도록 되어 있다. 그렇기에 동시에 여러 프로세스들을 실행하면 메모리, 스케쥴링 등의 상태를 관리하여 이 착각을 유지 할 수 있도록 하여야 한다.

지난 프로젝트에서는 테스트 코드를 직접적으로 커널에 컴파일하여서 커널 내의 특정 함수 인터페이스를 필요로 했었다.  
지금부터는 유저 프로그램을 실행시켜 운영체제를 테스트 할 것이기 때문에 훨씬 자유도가 높을 것이다.  
유저 프로그램 인터페이스는 뒤에 나올 사항들을 만족시켜야 하지만 그것만 아니면 커널 코드를 어떻게 바꿔도 상관 없다.  
모든 코드는 #ifdef VM 으로 싸여져 있는 블록에 존재 해서는 안된다. 해당 블록의 코드들은 다음 프로젝트에서 가상메모리 하위 시스템을 활성화 하고 나서 추가 될 것이다. 만약 코드가 #ifdef VM으로 묶여있다면 다음 프로젝트에서 생략될 것이다.

#### Virtual Address

이걸 이해하기 전에 계층적 페이지 테이블(Hierarchical Page Table)에 대한 이해가 선행 되어야 한다.

만약 페이지 테이블이 연속적이라면 보통 페이지의 크기가 4KB 이므로 32비트 주소체계와 64비트 주소체계일 때 각각 페이지 오프셋을 제외한 (32 - 12 = 20)(64 - 12 = 52) 비트 만큼 페이지 테이블이 가리킬 수 있으므로 총 페이지의 갯수는 $2^{20}$, $2^{52}$이다.  
각 페이지 테이블의 엔트리는 32, 64비트를 차지하므로 $2^{20}*4 byte = 4MB$, $2^{52}*8byte = 36PB$로 페이지 테이블의 크기가 어마어마함을 알 수 있다.

![hierarchicalPT](../../assets/img/post_img/20240904/hierarchicalPT.png){: style="display: block; margin-left: auto; margin-right: auto; width: 60%;" }

그 대안으로 나온 것이 계층적 페이지 테이블로, Page number을 다시 두 부분으로 나누어 페이지 테이블의 테이블을 만드는 것이다. 밑에서 우리가 보게 될 메모리는 4부분으로 나뉜 4계층 페이지 테이블이다.

가장 상위의 테이블은 outer page table 이라고 하고 그 하위의 페이지 테이블을 inner page table이라고 부르는데, outer page table의 입장에서 inner page table들은 하나의 페이지와 마찬가지기 때문에 물리 메모리에서 불연속적으로 존재할 수 있다.

![PT](../../assets/img/post_img/20240904/PT.png){: style="display: block; margin-left: auto; margin-right: auto; width: 60%;" }

다음은 32비트 주소체계에서의 2계층 페이지 테이블의 예시로 PT Number은 outer page table의 인덱스가 될 것이고, PT Offset은 inner page table의 몇 번째 entry인지를 나타내는 값이다.

이렇게 나누는 행위를 통해 각 페이지 테이블은 $2^{10} * 4 byte = 4KB$로 크기가 대폭 감소(이전에는 4MB)했고, 10, 10, 12 로 나뉘는 이유는 12비트는 페이지 내 오프셋으로 4KB의 페이지를 완전히 표현이 가능하고, 10비트로 1024가지의 엔트리를 표현할 수 있고, 각 엔트리는 4바이트이므로 페이지 테이블의 크기는 4KB로 페이지의 크기와 일치하게 된다.

이렇게 만들어진 outer page table은 커널 메모리에 저장되고, inner page table들은 유저 메모리에 저장되게 된다.

```mathematica
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |  Physical  |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                      Virtual Address
```

64비트의 가상 주소는 위 그림처럼 구성되어 있다.  
이를 위한 함수와 매크로는 다음과 같다.

```c
#define PGSHIFT 0
#define PGBITS 12
```

PGSHIFT는 첫 offset 비트의 인덱스를 나타내고, PGBITS는 offset 비트의 수를 나타낸다.

```c
#define PGMASK  BITMASK(PGSHIFT, PGBITS)
```

출처 : [계층적 페이지 테이블 사진](https://lwn.net/Articles/106177/)
