---
title: Week6_Day2
date: 2024-08-09 17:28:25 +09:00
categories: [크래프톤 정글, TIL, CSAPP]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    CSAPP,
    .
    .
    .
  ]
---

## 인자 전달 방식

함수에서 인자를 불러 올 때 어떤 방식으로 호출 하는가?

### Call by Value(복사)

함수의 인자를 받을 때 변수에 담긴 값을 스택에 복사하여 넘겨준다.

- 장점 : 원본 값을 변경할 수 없기 때문에 안전하다.
- 단점 : 복사를 하니까 메모리 공간을 차지 한다.

### Call by Reference(주소값)

함수의 인자를 받을 때 변수의 주소값을 넘겨준다.  
때문에 함수 내에서 해당 인자를 조작하면 원본 주소값의 원본 값 자체가 변한다.

- 장점 : 복사가 아닌 직접 참조이기 때문에 빠르다.
- 단점 : 원래 값이 변하는 리스크가 있다.

C에서는 사용자가 직접 컨트롤을 할 것이고 다른 언어에서는 어떨까?

### Python

Python에서는 Call by Assignment를 사용한다.

#### Call by Assignment(난둘다)

- Immutable Object : Call by Value 형식의 핸들링.
- Mutable Object : Call by Reference 형식의 핸들링.

### JavaScript

JS에서는 Call by Value만을 사용한다고 한다.

> Call by Sharing이란 말이 있으나 정식 명칭이 아니라 주의.  
> 뒤에서 설명하겠다.

예를 들어가며 살펴보자

```js
function change(arg) {
  arg = 3;
  console.log(arg); // 3
}

// function change() {
//     let arg = 1;
//     arg = 3;
//     console.log(a);
// } 이거랑 같은거야

a = 1;
change(a);
console.log(a); // 1
```

위와 같이 원시값은 주소 대신 값 자체를 복사하여 전달하기 때문에 함수 내부에서의 변경사항은 기존의 argument와 다른 값이여서 영향을 주지 못한다.

> 원시값 : 객체가 아니면서 메서드 또는 속성도 가지지 않는 데이터
> (string, number, bigint, boolean, undefined, symbol, null)

그렇다면 객체의 속성을 변경하게 된다면??

```js
function change(arg) {
  arg.x = 5;
  console.log(arg);
}

// function change() {
//     let arg = a;
//     arg.x = 5;
//     console.log(arg); // {x:5}
// } 이거랑 같은거야

a = { x: 1 };
change(a);
console.log(a); // {x:5}
```

객체 타입의 인자는 주소값을 갖는 새로운 변수가 되는데, 이 때 같은 객체를 바라보고있다.  
때문에 함수 내부에서 속성값을 변화시키면 외부의 속성값도 같이 변한다.

```js
function change(arg) {
  arg = 5;
  console.log(arg);
}

// function change() {
//     let arg = a;
//     arg = 5;
//     console.log(arg); // 5
// } 이거랑 같은거야

a = { x: 1 };
change(a);
console.log(a); // {x:5}
```

허나 값 자체를 수정하려 하는 경우 참조 관계가 깨지게 된다. 즉 함수내부의 변동사항이 외부의 값에 영향을 주지 않는다.

![example](../../assets/img/post_img/20240809/examples.jpg){: style="display: block; margin-left: auto; margin-right: auto; width: 60%;" }  
그림으로 2번과 3번 코드를 나타내면 다음과 같다.

위 코드들을 살펴보면 결과적으로 3번의 반례를 통해 js에는 call by reference가 존재 하지 않으며 2번을 통해 참조 타입의 인자 또한 복사를 통해 전달하기 때문에 결국 call by value만이 존재함을 알 수 있다.  
이 혼동을 방지하기 위해 call by sharing이라는 용어가 생겼지만 정식 용어가 아니다.

참고 문서: CSAPP, [MDN web docs](https://developer.mozilla.org/ko/docs/Glossary/Primitive "MDN"), [ZeroCho](https://www.youtube.com/watch?v=-w-oJp6OVd4&t=385s "ZeroCho")
