---
title: Week4_Day4
date: 2024-07-29 22:31:13 +09:00
categories: [크래프톤 정글, TIL]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    C,
    .
    .
    .
  ]
---

오늘은 어제에 이어서 c의 포인터에 대해 공부해 보았다.

#### 포인터의 포인터(더블 포인터)

더블포인터는 말 그대로 포인터를 가리키는 포인터이다.

```c
int **p;
```

이런 형태로 선언 한다.

```c
#include <stdio.h>

int main()
{
    int a;
    int *pa;
    int **ppa;

    pa = &a;
    ppa = &pa;

    a = 3;

    printf("a: %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);
    printf("&a : %p // pa : %p // *ppa : %p \n", &a, pa, *ppa);
    printf("&pa : %p // ppa : %p \n", &pa, ppa);

    return 0;
}

```

위 코드를 통해서 pa가 가리키는 값과 ppa에 역참조를 두번해서 가리키는 값이 같은 걸 확인할 수 있고, \*ppa는 pa와 함께 a의 주소값을 가지고, ppa는 pa의 주소값을 가지는 걸 눈으로 확인 할 수 있다.

<p align="center"><img src="../assets/img/post_img/20240728/double_pointer.png" width="400" height="300"/>
</p>

```c
#include <stdio.h>

int main()
{
    int arr[3] = {1, 2, 3};
    int(*parr)[3] = &arr;

    printf("arr[1] : %d \n", arr[1]);
    printf("parr[1] : %d \n", (*parr)[1]);
}
```

이때 &참조 연산자가 있기 때문에 arr의 타입변환은 일어나지 않고, 포인터가 크기가 3인 배열을 가리켜야 하는 것이다.

```c
int (*parr)[3] = &arr;
```

이 라인에서 저 문장을 수행하는 것이다. 이 때 꼭 괄호로 감싸주어야지 그냥 쓰게 된다면 int \* 원소 세개를 가지는 배열이 되어 버릴 것이다.

#### 2차원 배열

1차원 배열이 여러개 있다고 생각을 하면 되지만 주의 할 점은 컴퓨터의 메모리 구조는 1차원이기 때문에 2차원배열이던, 다차원 배열이던 모두 연속적으로 메모리에 존재한다.

<p align="center"><img src="../assets/img/post_img/20240729/2_way_array.png" width="300" height="400"/>
</p>

또한 arr[0]은 arr[0][0]의 주소값을 가지고, arr[1]은 arr[1][0]의 주소값을 가진다.  
이를 통해 1차원 배열에서의 arr과 마찬가지로, sizeof나 &를 만나는게 아니라면 암묵적으로 각 배열의 첫번째 원소를 가리키는 포인터로 타입 변환이 된다는 걸 알 수 있다.

앞서서 int arr[10] 이라는 배열이 있으면 arr[x]의 주소값은 arr + 4x라는 것을 배웠다. 그렇다면 2차원 배열에서는 어떻게 될까?  
int arr[a][b] 일 때 arr[x][y]의 주소값은 arr + 4bx + 4y가 된다.

그렇기 때문에 arr[x][y]의 주소값을 알기 위해선 x, y, b의 값을 알아야 한다는 걸 알 수 있다.  
2차원 배열을 가리키는 포인터를 통해서 원소에 접근을 하기 위해서는 원소의 크기, b의 값 두가지가 필요한 것이다.

```c
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3, 4, 5, 6}};
  int(*parr)[3];  // 괄호를 꼭 붙이세요

  parr = arr;  // parr 이 arr 을 가리키게 한다.

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}
```

위에서 보면

```c
/* (배열의 형) */ (*/* (포인터 이름) */)[/* 2 차원 배열의 열 개수 */];
// 예를 들어서
int (*parr)[3];
```

아까 언급했던 필요한 요소들을 넣어 둔 것이다.  
따라서 parr은 int 형 이차원 배열을 가리키는데, 그 배열의 한 행의 길이가 3이라는 것을 알 수 있다.

근데 잘 보면 아까 앞에서 했던 길이가 3인 배열을 가리키는 포인터라는 걸 알 수 있다.

이 때 2차원 배열에서 arr은 배열의 첫번째 원소 즉 첫 번째 행을 가리키기 때문에 길이가 3인 배열이다.

허나

```c
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **parr;

  parr = arr;

  printf("parr[1][1] : %d \n", parr[1][1]);  // 버그!

  return 0;
}
```

이렇게 하게 된다면, parr[1][1]은 \*(\*(parr + 1) + 1))과 같은 문장이고, parr + 1에서 parr 은 int*을 가리키는 포인터이고 +1을 하게 되면 실제주소 + 8과 같게 된다. 따라서 \*(parr + 1)은 3이 될 것이고, *(parr + 1) + 1을 하게 되면 int만큼 4가 증가 하기 때문에, 7번째 있는 값을 읽으라는 것이 되어서 오류가 발생한다.

## 포인터 배열

```c
#include <stdio.h>
int main() {
  int *arr[3];
  int a = 1, b = 2, c = 3;
  arr[0] = &a;
  arr[1] = &b;
  arr[2] = &c;

  printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
  printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
  printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

  printf("&a : %p, arr[0] : %p \n", &a, arr[0]);
  return 0;
}
```

int arr[3]이 int형 원소를 3개 가지는 배열이였듯이, int\* 각각의 원소들이 int를 가리키는 포인터로 취급된다는 것이다.

<p align="center"><img src="../assets/img/post_img/20240729/pointer_array.png" width="400" height="300"/>
</p>

## 문자열

기본적으로 컴퓨터는 문자열을 char 배열에 쭈르륵 나열 된 채로 저장한다.

<p align="center"><img src="../assets/img/post_img/20240729/string_memory.png" width="450" height="300"/>
</p>

근데 여기서 좀 귀찮아지는 점은 컴퓨터한테 문자열의 길이를 알려주어야 한다는 점이다.

#### Null 종료 문자

<p align="center"><img src="../assets/img/post_img/20240729/null_endpoint.png" width="450" height="300"/>
</p>

그렇기 때문에 문자열의 끝에 여기까지가 문자열이야. 를 알려주는 종료문자를 넣었다.  
이 종료문자는 아스키 값이 0이고, '\0'으로도 쓴다(문자 '0'과는 절대적으로 다르다). 이를 가리켜 Null이라고 한다.

이 종료문자가 들어갈 공간이 있어야 하기 때문에 3글자라고 하더라도 배열은 4칸이 필요하게 된다.

#### 참고

```c
char sentence_4[4] = {"Psi"};
```

이렇게 쓰면 알아서 각 문자를 따옴표로 표시해서 묶어준다. 이 때, Null문자는 자동으로 추가되기 때문에 따로 넣어주지 않아도 된다.

하지만 배열의 크기는 꼭 Null을 고려해서 4로 해야한다.

출력 할 때는

```c
%c // 한 문자만을 출력
%s // Null이 나올때까지 문자를 출력
```

<p align="center"><img src="../assets/img/post_img/20240729/asterisk.png" width="600" height="200"/>
</p>

또한 따옴표도 상황에 따라 용도가 다르니 표를 참고하는 것이 좋다.

#### 문자열의 입력

```c
#include <stdio.h>
int main() {
  char words[30];

  printf("30 자 이내의 문자열을 입력해주세요! : ");
  scanf("%s", words);

  printf("문자열 : %s \n", words);

  return 0;
}
```

위에서의 배열은 29글자 까지 저장할 수 있는 배열이다(Null 1개).

여기서 words앞에 &를 쓰지 않았는데 왜냐하면 words자체가 배열을 가리키는 포인터로 암묵적 타입변환이 되기 때문이다.

또한 주의해야 할 점은

```c
#include <stdio.h>
int main()
{
    int num;
    char c;

    printf("숫자를 입력하세요 : ");
    scanf("%d", &num);

    printf("문자를 입력하세요 : ");
    scanf("%c", &c);
    return 0;
}
```

우리가 입력값을 입력하면 그 값은 버퍼에 한번에 모았다가 뽑아쓰게 된다. 그런데, 1을 입력하고 엔터를 치면 \n까지 버퍼에 입력이 되게 된다.  
그럼 다음 문자 입력을 받는 부분은 \n을 먹고 바로 종료가 된 것이다.

허나 %s를 사용한다면 공백을 무시하고 실질적인 데이터가나오게 된다면 그 다음에 등장하는 공백문자에서 종료를 하기 때문에 개행을 무시하고 입력 받을 수 있다.

꼭 %c를 이용해야한다면 중간에 getchar()(한 문자를 얻어와서 리턴하는 함수)를 이용해서 버퍼를 비우고 사용할 수도 있지만 이왕이면 문자가아닌 문자열로 입력을 받는게 이상적이다.

#### 리터럴

```c
char str[] = "sentence";
char *pstr = "sentence";
```

위 코드를 보면 pstr에는 분명 char형 변수의 주소값이 들어가야 한다.  
이 때 저 문자열은 특정한 주소값(시작 주소값)을 나타낸다. 그렇기 때문에 에러가 발생하지 않고, %s를 통해 pstr을 출력해보면 sentence라는 문자열이 잘 출력 됨을 확인할 수 있다.

이제 "sentence"의 정체에 대해 알아보겠다

```c
#include <stdio.h>
int main() {
  char str[] = "hello";
  char *pstr = "goodbye";

  str[1] = 'a';
  pstr[1] = 'a';

  return 0;
}
```

이 코드는 pstr[1] = 'a'에서 오류가 발생하게 된다. 그렇다는 것은 pstr의 값을 변경하려 하였을 때 문제가 발생했다는 뜻이 된다.

리터럴이란 고정된 값을 가지는 것을 의미한다. c언어에서는 "" 큰따옴표로 묶인 것들을 문자열 리터럴이라고 부른다.  
컴퓨터는 이 리터럴들을 메모리 상의 특별한 곳에 따로 모아서 보관을 한다. 따라서 코드에서는 goodbye의 시작주소 좀 가져와서 pstr에 넣어라 가 가능한 것이다.

이 리터럴들이 저장되는 곳은 오직 읽기만 가능한 곳이다. 그렇기 때문에 우리가 ""를 사용해서 저장, 출력을 하면 기대한 결과가 나올 것을 보장 받을 수 있는 것이다.

따라서 아까 pstr[1] = 'a' 에서 읽기가 아닌 쓰기를 시도했을 때 감히!! 하고 에러가 발생한 것이다.

하지만 char str[] = "hello";의 경우에는 리터럴이라고 부르기가 애매하다 왜냐하면 컴파일러에서는 char str[] = {'h', 'e', 'l', 'l', 'o', '\0'}; 이렇게 해석이 되기 때문이다. 이 str안의 문자열들은 수정이 가능하게 된다.

#### 문자열 다루기

문자열의 덧셈은 불가능하다. 그 이유는

```c
char str1[] = {"abc"};
char str2[] = {"def"};
str1 = str1 + str2;
```

배열은 곧 포인터이기 때문에 str1, str2는 각 배열의 주소값을 나타낸다. 그렇기 때문에 대입연산이 불가능하다.

```c
if (str1 == str2)
```

이런식으로 비교를 하는 것 또한 의미가 없고,

```c
if (str1 == "abc")
```

이런식의 비교도 의미가 없어진다.

```c
str1 = str2;
```

int형 변수와 다르게 이렇게 복사조차 불가능 하기 때문에 사용하기가 정말 불편하다.

이를 함수를 이용해서 그래도 자유롭게 다룰 수가 있다.

#### 문자열을 복사하는 함수

함수를 만들기 전에는 3가지를 고려해야 한다.

1. 이 함수는 무슨 작업을 하는가.

2. 함수의 리턴형이 무엇이면 좋을까.

3. 함수의 인자로는 무엇을 받아야 하는가.

이 경우 우리는 a라는 문자열의 내용을 b로 복사하는 함수를 만들고 싶다.

복사가 성공적이라면 1을 리턴하도록 하고싶다. 즉 int 형의 함수를 만들겠다.

두 개의 문자열을 받아야 하므로 포인터를 사용해야 하고, char 형 배열이기 때문에 char\*를 인자로 2개 가지느 함수가 되겠다.

이제 만들어본다면

```c
int copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;  // 그 다음 문자를 가리킨다.
    dest++;
  }
  *dest = '\0';

  return 1;
}
```

while 문에서 *src를 통해서 null을 만날때 까지 순회를 한다. 이는 문자열을 다룰 때 자주 쓰는 방법이다.  
이후 복사를 진행하고 null을 만났을 때 종료를 했기 때문에 미처 null을 넣지 못해서 *dest에 null을 추가해준다.

```c
char str[100];
str = "abcdefg";
```

이렇게 하게 되면 str이라는 배열의 이름은 상수이기 때문에, 배열의 주소값이기 때문에 바꿀 수가 없어 에러가 발생한다.

```c
char str[100] = "abcdefg";
```

이렇게 사용했을 때는 오직 배열을 정의할 때만 사용이 가능하고, 예상한대로 작동하게 된다.
