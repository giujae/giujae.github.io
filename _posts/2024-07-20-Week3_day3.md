---
title: Week3_Day1
date: 2024-07-21 00:05:12 +09:00
categories: [크래프톤 정글, TIL]
pin: true
tags: [
    크래프톤 정글,
    TIL,
    PYTHON,
    .
    .
    .
  ]
---

오늘은 csapp3장을 이어서 공부했다.


## 제어문
반복문, 스위치문들은 조건부 실행이 요구됨.
기계어 코드에서 조건부 동작을 시행하는 법으론 데이터의 흐름 변경, 제어흐름의 변경 두 가지 방법이 있음.
먼저 제어 흐름에 대해서 알아볼 것.
### 조건 코드

cpu의 비교연산이나 테스트 연산 이후에 설정되는 cpu의 상태 플래그로 각 플래그는 1비트의 크기를 가지며 상태 레지스터나 플래그 레지스터에 저장됨.
이 레지스터들은 조건부 분기를 수행하기 위해 참고 됨.
>RFLAGS : cpu의 상태를 나타내는 플래그 비트들이 저장되는 64비트 레지스터로 x86_64에서는 상태 레지스터와 플래그 레지스터 모두의 대표적인 예시로 같은 개념을 지칭함.

**조건 코드의 대표적 종류**

- CF(Carry flag) : unsigned number의 덧셈과 뺄셈에서 올림 또는 빌림이 발생하면 설정되는 플래그.
>올림 : 덧셈을 했을 때 표현 가능한 범위를 넘어서면 발생.
ex) 0xFFFFFFFF(32비트의 최대 수) + 1 을 하게 되면 33비트의 수(0x100000000) 가 나오지만 이를 32비트로 표현하게 되면 상위 1비트가 잘린 0x00000000 즉 0 이 되어버린다.

  >빌림 : 뺄셈을 했을 때 음수가 나오면 발생. 실제로 음수 표현이 32비트를 넘어서는 것이 아니라, 음수 결과는 signed number로 해석 되기 때문에 32비트 unsigned number로는 표현 할 수 없어 플래그가 발생함.
 
- ZF(Zero flag) : 연산의 결과가 0이 되었을 때 설정되는 플래그.
- SF(Sign flag) : signed number에 대해서 연산의 결과가 음수가 발생하면 설정되는 플래그.
- OF(Overflow flag) : signed number의 연산에서 2의 보수 오버 플로우가 발생하면 설정되는 플래그.
> 2의 보수 : 음수를 표현할 때 2진법으로 나타낸 뒤 1을 더하여 음수를 표현하는 방법.

 ex) 8비트 signed number 에서 덧셈의 경우 127(0111 1111) 최대 양수 값에 1(0000 0001)을 더했을 때, 128이 되어야 하지만, 최대 값을 초과 하여 음수 범위로 넘어가기 때문에 -128(1000 0000)이 될 경우. 오버플로우가 발생함. 뺄셈의 경우에는 -128(1000 0000) 에서 -1(1111 1111)을 하게 되면 127(0111 1111)이 되어 오버플로우가 발생함. 이렇듯 양수 + 양수 = 음수 또는 음수 + 음수 = 양수가 되었을 경우 오버플로우가 발생함.
 
 ![](https://velog.velcdn.com/images/jju6924/post/6c7807bd-40d9-4fda-9549-48bd3375a3fc/image.png)

그림의 인스트럭션 중 leaq는 주소 계산에 사용하기 위한 것으로 조건 코드를 변경 시키지 않음. 이를 제외한 모든 인스트럭션들은 조건 코드 값을 변경시킴.
- XOR 같은 논리 연산에서 캐리와 오버플로우 플래그가 0으로 세팅.
- 쉬프트 연산에서는 캐리 플래그가 쉬프트 되어 없어지는 마지막 비트로 설정, 오버플로우 플래그는 0으로 세팅.
 
 ![](https://velog.velcdn.com/images/jju6924/post/b7453926-23a6-452c-b674-2580257460c0/image.jpg)
