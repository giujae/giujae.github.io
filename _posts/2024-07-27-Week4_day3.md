---
title: Week4_Day3
date: 2024-07-27 12:31:40 +09:00
categories: [크래프톤 정글, TIL]
pin: true
use_math: true
tags: [
    크래프톤 정글,
    TIL,
    C,
    .
    .
    .
  ]
---

어제에 이어서 C의 문법에 대해 이어 공부하였다.

## if 문

#### if문

지금까지의 코드들은 위에서부터 아래로 순서대로 실행되었었다.  
허나 조건문에서는 조건에 따라 실행되는 것이 달라 진다.

#### 코드

```c
#include <stdio.h>

int main(){
    int i;
    printf("입력하고 싶은 숫자를 입력하세요! : ");
    scanf("%d", &i);

    if(i == 7) {
        printf("당신은 행운의 숫자 7 을 입력했습니다");
    }
    return 0;
}
```

파이썬과 다른 부분만 짚고 넘어가겠다.

사실관계연산자는 연산 후에 참이면 1, 거짓이면 0을 나타낸다.

```c
#include <stdio.h>

int main() {
    double i, j;
    printf("나누고 싶은 두 정수를 입력하세요 : ");
    scanf("%lf %lf", &i, &j);

    printf("%f 를 %f 로 나눈 결과는 : %f \n", i, j, i / j);

    return 0;
}
```

그냥 if 문으로 조건 처리하면 0으로 나눌 경우를 거를 수 있다는 걸 보여주기 위한 예문인데 파이썬과 조금 차이가 있는 부분이 있었다.  
파이썬에는 0으로 나눗셈을 하면 division by 0라고 에러를 뱉는다.  
C에서는 int형일 경우 마찬가지로 에러를 뱉지만, double형일 경우 inf를 반환한다.

```c
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("행운의 숫자 7 이군요!\n");
  } else if (num == 4) {
    printf("죽음의 숫자 4 인가요 ;;; \n");
  } else {
    printf("그냥 평범한 숫자 %d \n", num);
  }
  return 0;
}
```

형태가 살짝 다르니 그냥 한 번 읽어만 보면 될 것 같다.  
">" "<" ">=" "<=" "==" "!=" 등의 비교연산자는 그대로 사용가능하다.

```c
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("a 행운의 숫자 7 이군요!\n");
  } else if (num == 7) {
    printf("b 행운의 숫자 7 이군요! \n");
  }

  // 비교
  if (num == 7) {
    printf("c 행운의 숫자 7 이군요!\n");
  }
  if (num == 7) {
    printf("d 행운의 숫자 7 이군요! \n");
  }

  return 0;
}
```

여기서 하나 볼만한게 있는 것 같은데 if-else와 if if의 차이를 보여주고 있다.  
모두 7을 입력했을 때 조건을 만족할 수 있지만, if-else의 경우 else문은 if조건이 아닐때~이기 때문에 b는 출력되지 않는다.

```c
#include <stdio.h>

int main() {
  int a = 31, b = 15;
  printf("a & b = %d\n", a & b);
  printf("a && b = %d\n", a && b);
}
```

여기서는 비교연산자 &, &&의 차이를 보여주고 있다.  
&의 경우 비트단위로 31과 15를 비교하지만, &&은 31이라는 참, 15 라는 참을 비교하기 때문에 1이 나오게 된다.  
파이썬의 AND와 비슷하다고 보면 될 것 같다.  
또한 0<= n < N의 표현은 불가능하다.  
위 예시에 있었듯이 n >= 0 and n < N 으로 표현해야한다.

## for문

파이썬의 for문과 형태만 살짝 다르다.

```c
#include <stdio.h>
int main() {
  int i, sum = 0;
  for (i = 0; i < 20; ++i) {
    sum = sum + i;
  }
  printf("1 부터 19 까지의 합 : %d", sum);

  return 0;
}
```

여기서 볼 수 있는 두가지는 먼저 sum += i라는 표현은 가능하다.  
두 번째로 int i, sum = 0;에서 혹시 i = 0, sum = 0으로 초기화 되나 싶었지만, i는 int자료형만 주어지고, sum 만 0으로 초기화 된다. 이후 for 문 내에서 i = 0으로 초기화 되어 사용된다.

```c
#include <stdio.h>

int main(){
    int usranswer;

    printf("컴퓨터가 생각한 숫자를 맞추어 보세요! \n");

    for(;;) {
        scanf("%d", &usranswer);
        if(usranswer == 3) {
            printf("맞춤! \n");
            break;
        } else {
            printf("틀렸어요! \n");
        }
    }
    return 0;
}
```

여기서는 처음 보는 문법을 봤다.  
for문안에 조건을 명시하지 않고 사용하여 python while True:와 같은 효과를 내는 것이였다.  
while문과 마찬가지로 break문으로 종료조건을 주지 않으면 무한 루프에 갇히게 된다.

> break : break아래로는 실행되지 않는다.  
> continue : for문을 탈출하지 않고 진행하던 부분을 그 부분에서 끝내고 바로 다음을 진행한다.

## While문

```c
#include <stdio.h>
int main() {
  int i = 1, sum = 0;

  while (i <= 100) {
    sum += i;
    i++;
  }

  printf("1 부터 100 까지의 합 : %d \n", sum);

  return 0;
}
```

while 문에서는 특이점은 없었다.  
while True를 사용하고 싶으면 0이 아닌 값은 true로 취급되기 때문에 조건 대신에 넣으면 된다.

## do-while 문

```c
#include <stdio.h>

int main() {
    int i = 1, sum = 0;

    do {
        sum += i;
        i++;
    } while (i < 1);
    printf(" sum : %d \n", sum);
    return 0;
}
```

기본적으로 while문이 뒤집어 졌다고 생각하면 편하다.
코드블럭이 위로오고, 조건검사부가 밑에있기 때문에 while 문과의 가장 큰 차이점은 조건을 통과하던 못하던 처음의 한 번은 무조건 실행 된다는 점이다.

## switch 문

if문과 굉장히 유사하게 작동하며

```c
#include <stdio.h>

int main() {
    int input;

    printf("마이펫 \n");
    printf("무엇을 하실 것인지 입력하세요 \n");
    printf("1. 밥주기 \n");
    printf("2. 씻기기 \n");
    printf("3. 재우기 \n");

    scanf("%d", &input);

    if (input == 1) {
        printf("아이 맛있어 \n");
    } else if (input == 2) {
        printf("아이 시원해 \n");
    } else if (input == 3) {
        printf("zzz \n");
    } else {
        printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
    }
    return 0;
}
```

여기서 볼 수 있듯이 명령을 더 추가하려면 else if가 계속 해서 늘어나게 된다.

이를 위해 사용하는게 switch문이다.

```c
#include <stdio.h>

int main() {
    int input;

    printf("마이펫 업그레이드\n");
    printf("무엇을 하실 것인지 입력하세요 \n");
    printf("1. 밥주기 \n");
    printf("2. 씻기기 \n");
    printf("3. 재우기 \n");

    scanf("%d", &input);

    switch (input) {
        case 1:
        printf("아이 맛있어 \n");
        break;
        case 2:
        printf("아이 시원해 \n");
        break;

        case 3:
        printf("zzz \n");
        break;

        default:
        printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
        break;
    }
    return 0;
}
```

기본적으로 위의 if문과 같은 결과가 나오지만 코드가 훨씬 가독성이 좋다.  
주의해야 할 점은 매 case마다 break를 꼭 걸어줘야 한다는 것이다.  
만약 case1에서 break를 빼먹게 된다면 아이 맛있어 와 아이 시원해가 모두 출력 될 것이다.  
즉 break를 써주지 않으면 다음 케이스까지 넘어간다는 뜻이다.  
만약 모든 case에 해당하지 않는다면 default로 들어가 코드블럭이 실행 된다.

또 주의해야 할 점은 input으로 사용 될 변수는 항상 정수 데이터를 보관해야 한다는 것이다.  
즉 char, short, int, long을 사용할 수 있다.

```c
#include <stdio.h>
int main() {
  char input;

  printf("(소문자) 알파벳 읽기\n");
  printf("알파벳 : ");

  scanf("%c", &input);

  switch (input) {
    case 'a':
      printf("에이 \n");
      break;

    case 'b':
      printf("비 \n");
      break;

    case 'c':
      printf("씨 \n");
      break;

    default:
      printf("죄송해요.. 머리가 나빠서 못 읽어요  \n");
      break;
  }

  return 0;
}
```

그렇다면 여기서는 왜 문자를 받는가?? 그 이유는 어제 공부했듯이 컴퓨터는 문자인지 숫자인지 구분을 하지 못하기 때문이다.

if문과 switch문의 작동과정은 csapp을 읽으면서도 잠깐 정리했었는데 간략하게 적어보자면,

if문의 경우에는 각 경우마다 값을 비교하기 때문에 최악의 경우에는 모든 case에 대해 값을 비교하는 CMP연산을 하게 된다.

반면 switch의 경우 jump를 하기 때문에, switch문이 실행 되기 전에 컴파일러에서 jump table의 구조를 만들고 어셈블러가 값을 채워넣는다.  
이때 이렇기 때문에 input값에 변수가 들어가면 jump table에 어떤 값을 넣어야 할 지 알 수가 없어서 넣으면 안되는 것이다.  
jump table에는 각 케이스별 코드블럭이 어디에 저장 되어있는지를 가리키는 포인터 배열이나 메모리 주소 배열이 저장되고, 위에서 부터 조건을 평가하면서 코드블럭에 접근하는 것이 아니라 배열의 인덱싱을 하듯 메모리 주소를 가지고 직접적으로 jump를 하기 때문에 훨씬 효율적이다.
